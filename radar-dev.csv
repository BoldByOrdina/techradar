name,ring,quadrant,isNew,description
Design systems,Adopt,Techniques,FALSE,"<p>As application development becomes increasingly dynamic and complex, it's a challenge to deliver accessible and usable products with consistent style. This is particularly true in larger organizations with multiple teams working on different products. <strong>Design systems</strong> define a collection of design patterns, component libraries and good design and engineering practices that ensure consistent digital products. Built on the corporate style guides of the past, design systems offer shared libraries and documents that are easy to find and use. Generally, guidance is written down as code and kept under version control so that the guide is less ambiguous and easier to maintain than simple documents. Design systems have become a standard approach when working across teams and disciplines in product development because they allow teams to focus. They can address strategic challenges around the product itself without reinventing the wheel every time a new visual component is needed.</p>"
Privacy-focused web analytics,Assess,Techniques,TRUE,"<p><strong>Privacy-focused web analytics</strong> is a technique for gathering web analytics without compromising end user privacy by keeping the end users truly anonymous. One surprising consequence of General Data Protection Regulation (GDPR) compliance is the decision taken by many organizations to degrade the user experience with complex cookie consent processes, especially when the user doesn't immediately consent to the ""all the cookies"" default settings. Privacy-focused web analytics has the dual benefit of both observing the spirit and letter of GDPR while also avoiding the need to introduce intrusive cookie consent forms. One implementation of this approach is <a href=""https://plausible.io/"">Plausible</a>.</p>"
Remote mob programming,Assess,Techniques,TRUE,"<p>Mob programming is one of those techniques that our teams have found to be easier when done remotely. <strong>Remote mob programming</strong> is allowing teams to quickly ""mob"" around an issue or piece of code without the physical constraints of only being able to fit so many people around a pairing station. Teams can quickly collaborate on an issue or piece of code without having to connect to a big display, book a physical meeting room or find a whiteboard.</p>"
GitOps,Hold,Techniques,TRUE,"<p>We suggest approaching <strong>GitOps</strong> with a degree of care, especially with regard to branching strategies. GitOps can be seen as a way of implementing <a href=""/radar/techniques/infrastructure-as-code"">infrastructure as code</a> that involves continuously synchronizing and applying infrastructure code from <a href=""/radar/tools/git"">Git</a> into various environments. When used with a ""branch per environment"" infrastructure, changes are promoted from one environment to the next by merging code. While treating code as the single source of truth is clearly a sound approach, we're seeing branch per environment lead to environmental drift and eventually environment-specific configs as code merges become problematic or even stop entirely. This is very similar to what we've seen in the past with <a href=""/radar/techniques/long-lived-branches-with-gitflow"">long-lived branches with GitFlow</a>.</p>"
Peer review equals pull request,Hold,Techniques,TRUE,"<p>Some organizations seem to think <strong>peer review equals pull request</strong>; they've taken the view that the only way to achieve a peer review of code is via a pull request. We've seen this approach create significant team bottlenecks as well as significantly degrade the quality of feedback as overloaded reviewers begin to simply reject requests. Although the argument could be made that this is one way to demonstrate code review ""regulatory compliance"" one of our clients was told this was invalid since there was no evidence the code was actually read by anyone prior to acceptance. Pull requests are only one way to manage the code review workflow; we urge people to consider other approaches, especially where there is a need to coach and pass on feedback carefully.</p>"
Materialize,Trial,Platforms,FALSE,"<p><strong><a href=""https://materialize.io/"">Materialize</a></strong> is a streaming database that enables you to do incremental computation without complicated data pipelines. Just describe your computations via standard SQL views and connect Materialize to the data stream. The underlying differential data flow engine performs incremental computation to provide consistent and correct output with minimal latency. Unlike traditional databases, there are no restrictions in defining these materialized views, and the computations are executed in real time. We've used Materialize, together with Spring Cloud Stream and Kafka, to query over streams of events for insights in a distributed event-driven system, and we quite like the setup.</p>"
Snowflake,Trial,Platforms,FALSE,"<p>Since we last mentioned <strong><a href=""https://www.snowflake.com/"">Snowflake</a></strong> in the Radar, we've gained more experience with it as well as with <a href=""/radar/techniques/data-mesh"">data mesh</a> as an alternative to data warehouses and lakes. Snowflake continues to impress with features like time travel, zero-copy cloning, data sharing and its marketplace. We also haven't found anything we don't like about it, all of which has led to our consultants generally preferring it over the alternatives. Redshift is moving toward storage and compute separation, which has been a strong point of Snowflake, but even with Redshift Spectrum it isn't as convenient and flexible to use, partly because it is bound by its Postgres heritage (we do still like <a href=""/radar/platforms/postgresql-for-nosql"">Postgres</a>, by the way). Federated queries can be a reason to go with Redshift. When it comes to operations, Snowflake is much simpler to run. <a href=""/radar/platforms/bigquery"">BigQuery</a>, which is another alternative, is very easy to operate, but in a multicloud setup Snowflake is a better choice. We can also report that we've used Snowflake successfully with <a href=""/radar/platforms/google-cloud-platform"">GCP</a>, <a href=""/radar/platforms/aws"">AWS</a>, and <a href=""/radar/platforms/azure"">Azure</a>.</p>"
Bit.dev,Assess,Platforms,TRUE,"<p><strong><a href=""https://bit.dev/"">Bit.dev</a></strong> is a cloud-hosted collaborative platform for UI components extracted, modularized and reused with <a href=""https://github.com/teambit/bit"">Bit</a>. <a href=""/radar/platforms/web-components-standard"">Web components</a> have been around for a while, but building a modern front-end application by assembling small, independent components extracted from other projects has never been easy. Bit was designed to let you do exactly that: extract a component from an existing library or project. You can either build your own service on top of Bit for component collaboration or use Bit.dev.</p>"
Azure Machine Learning,Hold,Platforms,TRUE,"<p>We've observed before that the cloud providers push more and more services onto the market. We've also documented our concerns that sometimes the services are made available when they're not quite ready for prime time. Unfortunately, in our experience, <strong><a href=""https://azure.microsoft.com/en-us/services/machine-learning/"">Azure Machine Learning</a></strong> falls into the latter category. One of several <a href=""https://towardsdatascience.com/top-8-no-code-machine-learning-platforms-you-should-use-in-2020-1d1801300dd0"">recent entrants</a> in the field of <a href=""/radar/techniques/bounded-low-code-platforms"">bounded low-code platforms</a>, Azure ML promises more convenience for data scientists. Ultimately, however, it doesn't live up to its promise; in fact, it still feels easier for our data scientists to work in Python. Despite significant efforts, we struggled to make it scale and lack of adequate documentation proved to be another issue which is why we moved it to the Hold ring.</p>"
Sentry,Adopt,Tools,FALSE,"<p><strong><a href=""https://sentry.io/"">Sentry</a></strong> has become the default choice for many of our teams when it comes to front-end error reporting. The convenience of features like the grouping of errors or defining patterns for discarding errors with certain parameters helps deal with the flood of errors coming from many end user devices. Integrating Sentry in your CD pipeline allows you to upload source maps for more efficient error debugging, and it helps easily trace back which errors occurred in which version of the software. We also appreciate that while Sentry is primarily a SaaS offering, its source code is publicly available and it can be used for free for smaller use cases and <a href=""https://develop.sentry.dev/self-hosted/"">self-hosting</a>.</p>"
Flipper,Trial,Tools,TRUE,"<p><strong><a href=""https://github.com/facebook/flipper"">Flipper</a></strong> is an extensible mobile application debugger. Out of the box it supports profiling, interactive layout inspection, log viewer and a network inspector for iOS, Android and <a href=""/radar/languages-and-frameworks/react-native"">React Native</a> applications. Compared to other debugging tools for mobile apps, we find Flipper to be lightweight, feature rich and easy to set up.</p>"
Angular Testing Library,Trial,languages-and-frameworks,TRUE,"<p>As we continue developing web applications in JavaScript, we continue enjoying the <a href=""/radar/languages-and-frameworks/testing-library"">Testing Library</a> approach of testing applications; and carry on exploring and gaining experience with its packages — beyond that of <a href=""/radar/languages-and-frameworks/react-testing-library"">React Testing Library</a>. <strong><a href=""https://testing-library.com/docs/angular-testing-library/intro/"">Angular Testing Library</a></strong> brings all the benefits of its family when testing UI components in a user-centric way, pushing for more maintainable tests focused primarily on behavior rather than testing UI implementation details. Although it falls short in documentation, Angular Testing Library does provide <a href=""https://github.com/testing-library/angular-testing-library/tree/master/apps/example-app/app/examples"">good sample tests</a> that helped us in getting started faster for various cases. We've had great success with this testing library in our <a href=""/radar/languages-and-frameworks/angular"">Angular</a> projects and advise you to trial this solid testing approach.</p>"
Blazor,Trial,languages-and-frameworks,FALSE,"<p>Although JavaScript and its ecosystem is dominant in the web UI development space, new opportunities are opening up with the emergence of <a href=""/radar/languages-and-frameworks/webassembly"">WebAssembly</a>. <strong><a href=""https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor"">Blazor</a></strong> continues to demand our attention; it's producing good results with our teams building interactive rich user interfaces using C# on top of WebAssembly. The fact that our teams can use C# on the frontend too allows them to share code and reuse existing libraries. That, along with the existing tooling for debugging and testing, such as <a href=""/radar/languages-and-frameworks/bunit"">bUnit</a>, make this open-source framework worth trying.</p>"
FastAPI,Trial,languages-and-frameworks,TRUE,"<p>We're seeing more teams adopting Python as the preferred language to build solutions, not just for data science but for back-end services too. In these scenarios, we're having good experiences with <strong><a href=""https://fastapi.tiangolo.com/"">FastAPI</a></strong> — a modern, fast (high-performance), web framework for building APIs with Python 3.6 or later. Additionally, this framework and its ecosystem include features such as API documentation using OpenAPI that allow our teams to focus on the business functionalities and quickly create REST APIs, which makes FastAPI a good alternative to existing solutions in this space.</p>"
LitElement,Trial,languages-and-frameworks,FALSE,"<p>Steady progress has been made since we first wrote about <a href=""/radar/platforms/web-components-standard"">Web Components</a> in 2014. <strong><a href=""https://lit-element.polymer-project.org/"">LitElement</a></strong>, part of the <a href=""https://www.polymer-project.org/"">Polymer Project</a>, is a simple library that you can use to create lightweight web components. It's really just a base class that removes the need for a lot of the common boilerplate, making writing web components a lot easier. We've had success using it on projects, and as we see the technology maturing and the library being well liked, LitElement is becoming more commonly used in our Web Components-based projects.</p>"
Next.js,Trial,languages-and-frameworks,FALSE,"<p>We've had a bit more experience using <strong><a href=""https://nextjs.org/"">Next.js</a></strong> for <a href=""/radar/languages-and-frameworks/react-js"">React</a> codebases since the last time we wrote about it. Next.js is an opinionated, zero-configuration framework that includes simplified routing, automatic compilation and bundling with <a href=""/radar/tools/webpack"">Webpack</a> and <a href=""/radar/tools/babel"">Babel</a>, fast hot reloading for a convenient developer workflow among other features. It provides server-side rendering by default, improves search engine optimization and the initial load time and supports incremental static generation. We've had positive experience reports from teams using Next.js and, given its large community, continue to be excited about the evolution of the framework.</p>"
Flutter for Web,Assess,languages-and-frameworks,TRUE,"<p>So far, <a href=""/radar/languages-and-frameworks/flutter"">Flutter</a> has primarily supported native iOS and Android applications. However, the Flutter team's vision is to support building applications on every platform. <strong>Flutter for Web</strong> is one step in that direction — it allows us to build apps for iOS, Android and the browser from the same codebase. It has been available for over a year now on the ""Beta"" channel, but with the recent Flutter 2.0 release, Flutter for Web has hit the stable milestone. In the initial release of web support, the Flutter team is focusing on <a href=""https://web.dev/what-are-pwas/"">progressive web apps</a>, <a href=""https://en.wikipedia.org/wiki/Single-page_application"">single-page apps</a> and expanding existing mobile apps to the web. The application and framework code (all in <a href=""/radar/languages-and-frameworks/google-dart"">Dart</a>) are compiled to JavaScript instead of ARM machine code, which is used for mobile applications. Flutter’s web engine offers a choice of two renderers: an HTML renderer, which uses HTML, CSS, Canvas and SVG, and a CanvasKit renderer that uses <a href=""/radar/languages-and-frameworks/webassembly"">WebAssembly</a> and WebGL to render Skia paint commands to the browser canvas. A few of our teams have started using Flutter for Web and like the initial results.</p>"
React Hook Form,Assess,languages-and-frameworks,TRUE,"<p>Building forms for the web remains one of the perennial challenges of front-end development, in particular with <a href=""/radar/languages-and-frameworks/react-js"">React</a>. Many of our teams working with React have been using <a href=""/radar/languages-and-frameworks/formik"">Formik</a> to make this easier, but some are now assessing <strong><a href=""https://react-hook-form.com/"">React Hook Form</a></strong> as a potential alternative. <a href=""/radar/languages-and-frameworks/react-hooks"">React Hooks</a> already existed when React Hook Form was created, so it could use them as a first-class concept: the framework is registering and tracking form elements as uncontrolled components via a hook, thereby significantly reducing the need for re-rendering. It's also quite lightweight in size and in the amount of boilerplate code needed.</p>"
River,Assess,languages-and-frameworks,TRUE,"<p>At the heart of many approaches to machine learning lies the creation of a model from a set of training data. Once a model is created, it can be used over and over again. However, the world isn't stationary, and often the model needs to change as new data becomes available. Simply re-running the model creation step can be slow and <a href=""https://medium.com/syncedreview/the-staggering-cost-of-training-sota-ai-models-e329e80fa82"">costly</a>. Incremental learning addresses this issue, making it possible to learn from streams of data incrementally to react to change faster. As a bonus the compute and memory requirements are lower and predictable. In our implementations we've had good experience with the <strong><a href=""https://riverml.xyz/dev/"">River</a></strong> framework, but so far we've added checks, sometimes manual, after updates to the model.</p>"
Webpack 5 Module Federation,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Angular,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
React,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
VueJs,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Nest,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Gatsby,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Cypress.js,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Playwright,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Jest,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
NGRX,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Drupal jak,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
ngxs,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Svelte,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Nuxt,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Testing Framework,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Tailwind,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
WebAssembly,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Webcomponents,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
JAMstack,Assess,Tools,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Stencil,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Storybook,Assess,languages-and-frameworks,TRUE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Chromatic,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"
Deno,Assess,languages-and-frameworks,FALSE,"<p>The release of the <strong><a href=""https://webpack.js.org/concepts/module-federation/"">Webpack 5 Module Federation</a></strong> feature has been highly anticipated by developers of <a href=""/radar/techniques/micro-frontends"">micro frontend</a> architectures. The feature introduces a more standardized way to optimize how module dependencies and shared code are managed and loaded. Module federation allows for the specification of shared modules, which helps with the deduplication of dependencies across micro frontends by loading code used by multiple modules only once. It also lets you distinguish between local and remote modules, where the remote modules are not actually part of the build itself but loaded asynchronously. Compared to build-time dependencies like npm packages, this can significantly simplify the deployment of a module update with many downstream dependencies. Be aware, though, that this requires you to bundle all of your micro frontends with Webpack, as opposed to approaches such as <a href=""/radar/techniques/import-maps-for-micro-frontends"">import maps</a>, which might eventually become part of the W3C standard.</p>"